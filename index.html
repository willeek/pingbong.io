<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Synthwave Penalty Shootout</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(180deg, #1a0b2e, #ff0077);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid #00ffcc;
      box-shadow: 0 0 20px #00ffcc;
      background: #0a031a;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size
    canvas.width = 800;
    canvas.height = 600;

    // Game objects
    const ball = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      radius: 10,
      speedX: 5,
      speedY: 5,
      color: '#00ffcc'
    };

    const goalkeeper1 = {
      x: 20,
      y: canvas.height / 2 - 75,
      width: 30, // Wider for goalkeeper
      height: 150, // Taller for goalkeeper
      speed: 8,
      color: '#9900ff',
      score: 0
    };

    const goalkeeper2 = {
      x: canvas.width - 50,
      y: canvas.height / 2 - 75,
      width: 30,
      height: 150,
      speed: 8,
      color: '#9900ff',
      score: 0
    };

    // Particle effects
    let particles = [];
    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 5 + 2;
        this.speedX = (Math.random() * 2 - 1) * 2;
        this.speedY = (Math.random() * 2 - 1) * 2;
        this.color = `hsl(${Math.random() * 60 + 180}, 100%, 50%)`;
        this.life = 30;
      }
      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life--;
        this.size *= 0.95;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // Strobe light effect
    let strobe = 0;
    let strobeDirection = 1;
    function updateStrobe() {
      strobe += strobeDirection * 0.05;
      if (strobe > 0.5 || strobe < 0) strobeDirection *= -1;
    }

    // Keyboard controls
    const keys = { w: false, s: false, ArrowUp: false, ArrowDown: false };
    document.addEventListener('keydown', (e) => {
      if (e.key in keys) keys[e.key] = true;
    });
    document.addEventListener('keyup', (e) => {
      if (e.key in keys) keys[e.key] = false;
    });

    // Game logic
    function update() {
      // Move goalkeepers
      if (keys.w && goalkeeper1.y > 0) goalkeeper1.y -= goalkeeper1.speed;
      if (keys.s && goalkeeper1.y < canvas.height - goalkeeper1.height) goalkeeper1.y += goalkeeper1.speed;
      if (keys.ArrowUp && goalkeeper2.y > 0) goalkeeper2.y -= goalkeeper2.speed;
      if (keys.ArrowDown && goalkeeper2.y < canvas.height - goalkeeper2.height) goalkeeper2.y += goalkeeper2.speed;

      // Move ball
      ball.x += ball.speedX;
      ball.y += ball.speedY;

      // Ball collision with top/bottom
      if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
        ball.speedY = -ball.speedY;
        createParticles(ball.x, ball.y, 10);
      }

      // Ball collision with goalkeepers
      if (
        (ball.x - ball.radius < goalkeeper1.x + goalkeeper1.width &&
         ball.y > goalkeeper1.y && ball.y < goalkeeper1.y + goalkeeper1.height) ||
        (ball.x + ball.radius > goalkeeper2.x &&
         ball.y > goalkeeper2.y && ball.y < goalkeeper2.y + goalkeeper2.height)
      ) {
        ball.speedX = -ball.speedX * 1.05; // Speed up slightly
        createParticles(ball.x, ball.y, 15);
      }

      // Score points (ball passes goalkeeper into goal)
      if (ball.x < 0) {
        goalkeeper2.score++;
        resetBall();
      } else if (ball.x > canvas.width) {
        goalkeeper1.score++;
        resetBall();
      }

      // Update particles
      particles = particles.filter(p => p.life > 0);
      particles.forEach(p => p.update());
      updateStrobe();
    }

    function createParticles(x, y, count) {
      for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y));
      }
    }

    function resetBall() {
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      ball.speedX = (Math.random() > 0.5 ? 5 : -5) * (Math.random() * 0.5 + 0.8);
      ball.speedY = (Math.random() * 10 - 5) * (Math.random() * 0.5 + 0.8);
    }

    // Rendering
    function draw() {
      // Clear canvas with slight fade for trail effect
      ctx.fillStyle = `rgba(10, 3, 26, ${1 - strobe})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw center line
      ctx.beginPath();
      ctx.setLineDash([10, 15]);
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.strokeStyle = '#00ffcc';
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw goalposts (simple lines at edges)
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, canvas.height);
      ctx.moveTo(canvas.width, 0);
      ctx.lineTo(canvas.width, canvas.height);
      ctx.strokeStyle = '#ff0077';
      ctx.stroke();

      // Draw goalkeepers with glow
      ctx.fillStyle = goalkeeper1.color;
      ctx.shadowColor = '#9900ff';
      ctx.shadowBlur = 20;
      ctx.fillRect(goalkeeper1.x, goalkeeper1.y, goalkeeper1.width, goalkeeper1.height);
      ctx.fillStyle = goalkeeper2.color;
      ctx.fillRect(goalkeeper2.x, goalkeeper2.y, goalkeeper2.width, goalkeeper2.height);
      ctx.shadowBlur = 0;

      // Draw ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = ball.color;
      ctx.fill();

      // Draw particles
      particles.forEach(p => p.draw());

      // Draw scores
      ctx.font = '40px Arial';
      ctx.fillStyle = '#00ffcc';
      ctx.fillText(goalkeeper1.score, canvas.width / 4, 50);
      ctx.fillText(goalkeeper2.score, 3 * canvas.width / 4, 50);
    }

    // Game loop
    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Start game
    gameLoop();
  </script>
</body>
</html>